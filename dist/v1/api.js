"use strict";
/**
 * Houses of the Oireachtas Open Data APIs
 * The Houses of the Oireachtas is providing these APIs to allow our datasets to be retrieved and reused as widely as possible. They are intended to be used in conjunction with https://data.oireachtas.ie, from where our datasets can be accessed directly. By using the APIs, users can make metadata queries to identify the specific data they require. New data are available through the API as soon as they are published.  Currently, https://data.oireachtas.ie contains data in XML format from the Official Report of the Houses of the Oireachtas (the \"debates\") and replies to Parliamentary Questions in XML files complying with the [Akoma Ntoso](http://akomantoso.org) schema, as well data in PDF format for Bills, Acts and other documents published by the Houses of the Oireachtas.  Files can be retrieved from https://data.oireachtas.ie by adding the URI fragment contained in the \"formats\" fields of the JSON documents returned by these APIs. At the moment only PDF and XML files are available directly from https://data.oireachtas.ie, but this will become the endpoint for direct access of all \"uri\" fields in the data queried through https://api.oireachtas.ie. We will also be making bulk downloads available through https://data.oireachtas.ie.  Please note the APIs are a work in progress. We are working on expanding the range of datasets we publish, and we are interested in hearing about how to make these APIs more useful and wide ranging. For these reasons, we welcome any feedback, suggestions and user stories to open.data@oireachtas.ie  Data published through these APIs are made available under the [Oireachtas (Open Data) PSI Licence](https://beta.oireachtas.ie/en/open-data/license/)
 *
 * OpenAPI spec version: 1.0
 * Contact: open.data@oireachtas.ie
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
Object.defineProperty(exports, "__esModule", { value: true });
const request = require("request");
const Promise = require("bluebird");
let defaultBasePath = 'https://api.oireachtas.ie/v1';
// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================
/* tslint:disable:no-unused-variable */
class Act {
}
exports.Act = Act;
class AmendmentList {
}
exports.AmendmentList = AmendmentList;
class AmendmentlistFormats {
}
exports.AmendmentlistFormats = AmendmentlistFormats;
class Debate {
}
exports.Debate = Debate;
class DebateFormats {
}
exports.DebateFormats = DebateFormats;
class DebateSpeaker {
}
exports.DebateSpeaker = DebateSpeaker;
class DebateSpeakerRole {
}
exports.DebateSpeakerRole = DebateSpeakerRole;
(function (DebateSpeakerRole) {
    let RoleTypeEnum;
    (function (RoleTypeEnum) {
        RoleTypeEnum[RoleTypeEnum["Office"] = 'office'] = "Office";
        RoleTypeEnum[RoleTypeEnum["Position"] = 'position'] = "Position";
        RoleTypeEnum[RoleTypeEnum["Minister"] = 'minister'] = "Minister";
        RoleTypeEnum[RoleTypeEnum["MinisterState"] = 'minister_state'] = "MinisterState";
    })(RoleTypeEnum = DebateSpeakerRole.RoleTypeEnum || (DebateSpeakerRole.RoleTypeEnum = {}));
})(DebateSpeakerRole = exports.DebateSpeakerRole || (exports.DebateSpeakerRole = {}));
class DebateText {
}
exports.DebateText = DebateText;
(function (DebateText) {
    let TextTypeEnum;
    (function (TextTypeEnum) {
        TextTypeEnum[TextTypeEnum["Heading"] = 'heading'] = "Heading";
        TextTypeEnum[TextTypeEnum["Speech"] = 'speech'] = "Speech";
        TextTypeEnum[TextTypeEnum["Question"] = 'question'] = "Question";
        TextTypeEnum[TextTypeEnum["Table"] = 'table'] = "Table";
        TextTypeEnum[TextTypeEnum["Summary"] = 'summary'] = "Summary";
    })(TextTypeEnum = DebateText.TextTypeEnum || (DebateText.TextTypeEnum = {}));
})(DebateText = exports.DebateText || (exports.DebateText = {}));
class ErrorResponse {
}
exports.ErrorResponse = ErrorResponse;
class Event {
}
exports.Event = Event;
class EventChamber {
}
exports.EventChamber = EventChamber;
class EventDates {
}
exports.EventDates = EventDates;
class EventHouse {
}
exports.EventHouse = EventHouse;
(function (EventHouse) {
    let HouseCodeEnum;
    (function (HouseCodeEnum) {
        HouseCodeEnum[HouseCodeEnum["Dail"] = 'dail'] = "Dail";
        HouseCodeEnum[HouseCodeEnum["Seanad"] = 'seanad'] = "Seanad";
    })(HouseCodeEnum = EventHouse.HouseCodeEnum || (EventHouse.HouseCodeEnum = {}));
    let ChamberCodeEnum;
    (function (ChamberCodeEnum) {
        ChamberCodeEnum[ChamberCodeEnum["Dail"] = 'dail'] = "Dail";
        ChamberCodeEnum[ChamberCodeEnum["Seanad"] = 'seanad'] = "Seanad";
    })(ChamberCodeEnum = EventHouse.ChamberCodeEnum || (EventHouse.ChamberCodeEnum = {}));
    let ChamberTypeEnum;
    (function (ChamberTypeEnum) {
        ChamberTypeEnum[ChamberTypeEnum["House"] = 'house'] = "House";
        ChamberTypeEnum[ChamberTypeEnum["Committee"] = 'committee'] = "Committee";
    })(ChamberTypeEnum = EventHouse.ChamberTypeEnum || (EventHouse.ChamberTypeEnum = {}));
})(EventHouse = exports.EventHouse || (exports.EventHouse = {}));
class Formats {
}
exports.Formats = Formats;
class Head {
}
exports.Head = Head;
(function (Head) {
    let LangEnum;
    (function (LangEnum) {
        LangEnum[LangEnum["En"] = 'en'] = "En";
        LangEnum[LangEnum["Ga"] = 'ga'] = "Ga";
        LangEnum[LangEnum["Mul"] = 'mul'] = "Mul";
    })(LangEnum = Head.LangEnum || (Head.LangEnum = {}));
})(Head = exports.Head || (exports.Head = {}));
class HeadDateRange {
}
exports.HeadDateRange = HeadDateRange;
class InlineResponse200 {
}
exports.InlineResponse200 = InlineResponse200;
class InlineResponse2001 {
}
exports.InlineResponse2001 = InlineResponse2001;
class InlineResponse2001Question {
}
exports.InlineResponse2001Question = InlineResponse2001Question;
(function (InlineResponse2001Question) {
    let QuestionTypeEnum;
    (function (QuestionTypeEnum) {
        QuestionTypeEnum[QuestionTypeEnum["Oral"] = 'oral'] = "Oral";
        QuestionTypeEnum[QuestionTypeEnum["Written"] = 'written'] = "Written";
    })(QuestionTypeEnum = InlineResponse2001Question.QuestionTypeEnum || (InlineResponse2001Question.QuestionTypeEnum = {}));
})(InlineResponse2001Question = exports.InlineResponse2001Question || (exports.InlineResponse2001Question = {}));
class InlineResponse2001QuestionBy {
}
exports.InlineResponse2001QuestionBy = InlineResponse2001QuestionBy;
class InlineResponse2001QuestionDebateSection {
}
exports.InlineResponse2001QuestionDebateSection = InlineResponse2001QuestionDebateSection;
class InlineResponse2001QuestionDebateSectionFormats {
}
exports.InlineResponse2001QuestionDebateSectionFormats = InlineResponse2001QuestionDebateSectionFormats;
class InlineResponse2001QuestionDebateSectionFormatsPdf {
}
exports.InlineResponse2001QuestionDebateSectionFormatsPdf = InlineResponse2001QuestionDebateSectionFormatsPdf;
class InlineResponse2001QuestionDebateSectionFormatsXml {
}
exports.InlineResponse2001QuestionDebateSectionFormatsXml = InlineResponse2001QuestionDebateSectionFormatsXml;
class InlineResponse2001QuestionTo {
}
exports.InlineResponse2001QuestionTo = InlineResponse2001QuestionTo;
(function (InlineResponse2001QuestionTo) {
    let RoleTypeEnum;
    (function (RoleTypeEnum) {
        RoleTypeEnum[RoleTypeEnum["Office"] = 'office'] = "Office";
        RoleTypeEnum[RoleTypeEnum["Minister"] = 'minister'] = "Minister";
    })(RoleTypeEnum = InlineResponse2001QuestionTo.RoleTypeEnum || (InlineResponse2001QuestionTo.RoleTypeEnum = {}));
})(InlineResponse2001QuestionTo = exports.InlineResponse2001QuestionTo || (exports.InlineResponse2001QuestionTo = {}));
class InlineResponse2001Results {
}
exports.InlineResponse2001Results = InlineResponse2001Results;
class InlineResponse2002 {
}
exports.InlineResponse2002 = InlineResponse2002;
class InlineResponse2002DebateRecord {
}
exports.InlineResponse2002DebateRecord = InlineResponse2002DebateRecord;
class InlineResponse2002DebateRecordChamber {
}
exports.InlineResponse2002DebateRecordChamber = InlineResponse2002DebateRecordChamber;
(function (InlineResponse2002DebateRecordChamber) {
    let UriEnum;
    (function (UriEnum) {
        UriEnum[UriEnum["Housedail"] = '/ie/oireachtas/house/dail'] = "Housedail";
        UriEnum[UriEnum["Houseseanad"] = '/ie/oireachtas/house/seanad'] = "Houseseanad";
        UriEnum[UriEnum["Committee"] = '/ie/oireachtas/committee'] = "Committee";
    })(UriEnum = InlineResponse2002DebateRecordChamber.UriEnum || (InlineResponse2002DebateRecordChamber.UriEnum = {}));
})(InlineResponse2002DebateRecordChamber = exports.InlineResponse2002DebateRecordChamber || (exports.InlineResponse2002DebateRecordChamber = {}));
class InlineResponse2002DebateRecordCounts {
}
exports.InlineResponse2002DebateRecordCounts = InlineResponse2002DebateRecordCounts;
class InlineResponse2002DebateRecordDebateSection {
}
exports.InlineResponse2002DebateRecordDebateSection = InlineResponse2002DebateRecordDebateSection;
class InlineResponse2002DebateRecordDebateSectionBill {
}
exports.InlineResponse2002DebateRecordDebateSectionBill = InlineResponse2002DebateRecordDebateSectionBill;
class InlineResponse2002DebateRecordDebateSectionBillEvent {
}
exports.InlineResponse2002DebateRecordDebateSectionBillEvent = InlineResponse2002DebateRecordDebateSectionBillEvent;
class InlineResponse2002DebateRecordDebateSectionCounts {
}
exports.InlineResponse2002DebateRecordDebateSectionCounts = InlineResponse2002DebateRecordDebateSectionCounts;
class InlineResponse2002DebateRecordDebateSectionFormats {
}
exports.InlineResponse2002DebateRecordDebateSectionFormats = InlineResponse2002DebateRecordDebateSectionFormats;
class InlineResponse2002DebateRecordDebateSectionFormatsPdf {
}
exports.InlineResponse2002DebateRecordDebateSectionFormatsPdf = InlineResponse2002DebateRecordDebateSectionFormatsPdf;
class InlineResponse2002DebateRecordDebateSectionParentDebateSection {
}
exports.InlineResponse2002DebateRecordDebateSectionParentDebateSection = InlineResponse2002DebateRecordDebateSectionParentDebateSection;
class InlineResponse2002DebateRecordDebateSectionSpeakers {
}
exports.InlineResponse2002DebateRecordDebateSectionSpeakers = InlineResponse2002DebateRecordDebateSectionSpeakers;
class InlineResponse2002DebateRecordDebateSections {
}
exports.InlineResponse2002DebateRecordDebateSections = InlineResponse2002DebateRecordDebateSections;
class InlineResponse2002DebateRecordHouse {
}
exports.InlineResponse2002DebateRecordHouse = InlineResponse2002DebateRecordHouse;
(function (InlineResponse2002DebateRecordHouse) {
    let HouseCodeEnum;
    (function (HouseCodeEnum) {
        HouseCodeEnum[HouseCodeEnum["Dail"] = 'dail'] = "Dail";
        HouseCodeEnum[HouseCodeEnum["Seanad"] = 'seanad'] = "Seanad";
    })(HouseCodeEnum = InlineResponse2002DebateRecordHouse.HouseCodeEnum || (InlineResponse2002DebateRecordHouse.HouseCodeEnum = {}));
    let ChamberTypeEnum;
    (function (ChamberTypeEnum) {
        ChamberTypeEnum[ChamberTypeEnum["House"] = 'house'] = "House";
        ChamberTypeEnum[ChamberTypeEnum["Committee"] = 'committee'] = "Committee";
    })(ChamberTypeEnum = InlineResponse2002DebateRecordHouse.ChamberTypeEnum || (InlineResponse2002DebateRecordHouse.ChamberTypeEnum = {}));
})(InlineResponse2002DebateRecordHouse = exports.InlineResponse2002DebateRecordHouse || (exports.InlineResponse2002DebateRecordHouse = {}));
class InlineResponse2002Results {
}
exports.InlineResponse2002Results = InlineResponse2002Results;
class InlineResponse2003 {
}
exports.InlineResponse2003 = InlineResponse2003;
class InlineResponse2003Division {
}
exports.InlineResponse2003Division = InlineResponse2003Division;
class InlineResponse2003DivisionDebate {
}
exports.InlineResponse2003DivisionDebate = InlineResponse2003DivisionDebate;
class InlineResponse2003DivisionDebateFormats {
}
exports.InlineResponse2003DivisionDebateFormats = InlineResponse2003DivisionDebateFormats;
class InlineResponse2003DivisionDebateFormatsPdf {
}
exports.InlineResponse2003DivisionDebateFormatsPdf = InlineResponse2003DivisionDebateFormatsPdf;
class InlineResponse2003DivisionDebateFormatsXml {
}
exports.InlineResponse2003DivisionDebateFormatsXml = InlineResponse2003DivisionDebateFormatsXml;
class InlineResponse2003DivisionHouse {
}
exports.InlineResponse2003DivisionHouse = InlineResponse2003DivisionHouse;
class InlineResponse2003DivisionTallies {
}
exports.InlineResponse2003DivisionTallies = InlineResponse2003DivisionTallies;
class InlineResponse2003Results {
}
exports.InlineResponse2003Results = InlineResponse2003Results;
class InlineResponse200Bill {
}
exports.InlineResponse200Bill = InlineResponse200Bill;
(function (InlineResponse200Bill) {
    let StatusEnum;
    (function (StatusEnum) {
        StatusEnum[StatusEnum["Defeated"] = 'Defeated'] = "Defeated";
        StatusEnum[StatusEnum["Enacted"] = 'Enacted'] = "Enacted";
        StatusEnum[StatusEnum["Lapsed"] = 'Lapsed'] = "Lapsed";
        StatusEnum[StatusEnum["Current"] = 'Current'] = "Current";
        StatusEnum[StatusEnum["Withdrawn"] = 'Withdrawn'] = "Withdrawn";
        StatusEnum[StatusEnum["Rejected"] = 'Rejected'] = "Rejected";
    })(StatusEnum = InlineResponse200Bill.StatusEnum || (InlineResponse200Bill.StatusEnum = {}));
    let BillTypeEnum;
    (function (BillTypeEnum) {
        BillTypeEnum[BillTypeEnum["Public"] = 'Public'] = "Public";
        BillTypeEnum[BillTypeEnum["Private"] = 'Private'] = "Private";
        BillTypeEnum[BillTypeEnum["Hybrid"] = 'Hybrid'] = "Hybrid";
    })(BillTypeEnum = InlineResponse200Bill.BillTypeEnum || (InlineResponse200Bill.BillTypeEnum = {}));
})(InlineResponse200Bill = exports.InlineResponse200Bill || (exports.InlineResponse200Bill = {}));
class InlineResponse200BillAmendmentLists {
}
exports.InlineResponse200BillAmendmentLists = InlineResponse200BillAmendmentLists;
class InlineResponse200BillMostRecentStage {
}
exports.InlineResponse200BillMostRecentStage = InlineResponse200BillMostRecentStage;
class InlineResponse200BillOriginHouse {
}
exports.InlineResponse200BillOriginHouse = InlineResponse200BillOriginHouse;
class InlineResponse200BillVersion {
}
exports.InlineResponse200BillVersion = InlineResponse200BillVersion;
(function (InlineResponse200BillVersion) {
    let LangEnum;
    (function (LangEnum) {
        LangEnum[LangEnum["Eng"] = 'eng'] = "Eng";
        LangEnum[LangEnum["Gle"] = 'gle'] = "Gle";
    })(LangEnum = InlineResponse200BillVersion.LangEnum || (InlineResponse200BillVersion.LangEnum = {}));
})(InlineResponse200BillVersion = exports.InlineResponse200BillVersion || (exports.InlineResponse200BillVersion = {}));
class InlineResponse200BillVersions {
}
exports.InlineResponse200BillVersions = InlineResponse200BillVersions;
class InlineResponse200Results {
}
exports.InlineResponse200Results = InlineResponse200Results;
class MemberTally {
}
exports.MemberTally = MemberTally;
class MemberTallyMember {
}
exports.MemberTallyMember = MemberTallyMember;
class MemberTallyMembers {
}
exports.MemberTallyMembers = MemberTallyMembers;
class RelatedDoc {
}
exports.RelatedDoc = RelatedDoc;
class Sponsor {
}
exports.Sponsor = Sponsor;
class SponsorSponsor {
}
exports.SponsorSponsor = SponsorSponsor;
class VersionFormats {
}
exports.VersionFormats = VersionFormats;
class HttpBasicAuth {
    applyToRequest(requestOptions) {
        requestOptions.auth = {
            username: this.username, password: this.password
        };
    }
}
exports.HttpBasicAuth = HttpBasicAuth;
class ApiKeyAuth {
    constructor(location, paramName) {
        this.location = location;
        this.paramName = paramName;
    }
    applyToRequest(requestOptions) {
        if (this.location == "query") {
            requestOptions.qs[this.paramName] = this.apiKey;
        }
        else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}
exports.ApiKeyAuth = ApiKeyAuth;
class OAuth {
    applyToRequest(requestOptions) {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}
exports.OAuth = OAuth;
class VoidAuth {
    applyToRequest(_) {
        // Do nothing
    }
}
exports.VoidAuth = VoidAuth;
var ConstituenciesApiApiKeys;
(function (ConstituenciesApiApiKeys) {
})(ConstituenciesApiApiKeys = exports.ConstituenciesApiApiKeys || (exports.ConstituenciesApiApiKeys = {}));
class ConstituenciesApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[ConstituenciesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns list of constituencies filtered by the base and additional parameters. The list supports paging.  #### Mapping * Start Date - Greater Than or Equal To - question.date * End Date - Less Than or Equal To - question.date * Skip - Equal To - this will ignore the first x number of records set in the parameter * Limit - Equal To - this will only return a specific amount of records * House/Chamber - house.house.uri
     * @summary Constituencies List
     * @param chamberId Filter by house or committee uri. Example  /ie/oireachtas/house/dail/32
     * @param chamber Filter by House name (dail or seanad). Using an empty string retrieves results for both Houses.
     * @param houseNo filter by house number
     * @param skip This is a base filter which is used on many APIs, allowing skipping of records by a specific integer.
     * @param limit This is a base filter which is used on many APIs, allowing the limiting of records to a specific integer.
     */
    constituencies(chamberId, chamber, houseNo, skip, limit) {
        const localVarPath = this.basePath + '/constituencies';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (chamberId !== undefined) {
            queryParameters['chamber_id'] = chamberId;
        }
        if (chamber !== undefined) {
            queryParameters['chamber'] = chamber;
        }
        if (houseNo !== undefined) {
            queryParameters['house_no'] = houseNo;
        }
        if (skip !== undefined) {
            queryParameters['skip'] = skip;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.ConstituenciesApi = ConstituenciesApi;
var DebatesApiApiKeys;
(function (DebatesApiApiKeys) {
})(DebatesApiApiKeys = exports.DebatesApiApiKeys || (exports.DebatesApiApiKeys = {}));
class DebatesApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[DebatesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns list of debates filtered by the base and additional parameters. The list supports paging. #### Mapping * Start Date - Greater Than or Equal To - debateRecord.date * End Date - Less Than or Equal To - debateRecord.date * Skip - Equal To - this will ignore the first x number of records set in the parameter * Limit - Equal To - this will only return a specific amount of records
     * @summary Debates List
     * @param chamberType Filter results by House, ie, Dáil or Seanad or committees.
     * @param chamberId Filter by house or committee uri. Example  /ie/oireachtas/house/dail/32
     * @param chamber Filter by House name (dail or seanad). Using an empty string retrieves results for both Houses.
     * @param dateStart This is a base filter which is used on many APIs, allowing filtering by Start Date related to the Section.
     * @param dateEnd This is a base filter which is used on many APIs, allowing filtering by End Date related to the Section.
     * @param skip This is a base filter which is used on many APIs, allowing skipping of records by a specific integer.
     * @param limit This is a base filter which is used on many APIs, allowing the limiting of records to a specific integer.
     * @param memberId Filter by Member uri.
     * @param debateId Filter by debate uri
     */
    debates(chamberType, chamberId, chamber, dateStart, dateEnd, skip, limit, memberId, debateId) {
        const localVarPath = this.basePath + '/debates';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (chamberType !== undefined) {
            queryParameters['chamber_type'] = chamberType;
        }
        if (chamberId !== undefined) {
            queryParameters['chamber_id'] = chamberId;
        }
        if (chamber !== undefined) {
            queryParameters['chamber'] = chamber;
        }
        if (dateStart !== undefined) {
            queryParameters['date_start'] = dateStart;
        }
        if (dateEnd !== undefined) {
            queryParameters['date_end'] = dateEnd;
        }
        if (skip !== undefined) {
            queryParameters['skip'] = skip;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (memberId !== undefined) {
            queryParameters['member_id'] = memberId;
        }
        if (debateId !== undefined) {
            queryParameters['debate_id'] = debateId;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.DebatesApi = DebatesApi;
var DivisionsApiApiKeys;
(function (DivisionsApiApiKeys) {
})(DivisionsApiApiKeys = exports.DivisionsApiApiKeys || (exports.DivisionsApiApiKeys = {}));
class DivisionsApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[DivisionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * This will return a list of divisions which meet certain criteria #### Indexes * division_meta  #### Mapping * Division outcome - Equal To - division.outcome * Start Date - Greater than or Equal To - division.date * End Date - Greater than or Equal To - division.date
     * @summary Divisions
     * @param chamberType Filter results by House, ie, Dáil or Seanad or committees.
     * @param chamberId Filter by house or committee uri. Example  /ie/oireachtas/house/dail/32
     * @param chamber Filter by House name (dail or seanad). Using an empty string retrieves results for both Houses.
     * @param dateStart This is a base filter which is used on many APIs, allowing filtering by Start Date related to the Section.
     * @param dateEnd This is a base filter which is used on many APIs, allowing filtering by End Date related to the Section.
     * @param skip This is a base filter which is used on many APIs, allowing skipping of records by a specific integer.
     * @param limit This is a base filter which is used on many APIs, allowing the limiting of records to a specific integer.
     * @param outcome Filter divisions by outcome
     * @param memberId Filter by Member uri.
     * @param debateId Filter by debate uri
     * @param voteId Division Identifier for a Single Division
     */
    divisions(chamberType, chamberId, chamber, dateStart, dateEnd, skip, limit, outcome, memberId, debateId, voteId) {
        const localVarPath = this.basePath + '/divisions';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (chamberType !== undefined) {
            queryParameters['chamber_type'] = chamberType;
        }
        if (chamberId !== undefined) {
            queryParameters['chamber_id'] = chamberId;
        }
        if (chamber !== undefined) {
            queryParameters['chamber'] = chamber;
        }
        if (dateStart !== undefined) {
            queryParameters['date_start'] = dateStart;
        }
        if (dateEnd !== undefined) {
            queryParameters['date_end'] = dateEnd;
        }
        if (skip !== undefined) {
            queryParameters['skip'] = skip;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (outcome !== undefined) {
            queryParameters['outcome'] = outcome;
        }
        if (memberId !== undefined) {
            queryParameters['member_id'] = memberId;
        }
        if (debateId !== undefined) {
            queryParameters['debate_id'] = debateId;
        }
        if (voteId !== undefined) {
            queryParameters['vote_id'] = voteId;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.DivisionsApi = DivisionsApi;
var HousesApiApiKeys;
(function (HousesApiApiKeys) {
})(HousesApiApiKeys = exports.HousesApiApiKeys || (exports.HousesApiApiKeys = {}));
class HousesApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[HousesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns a house. #### Indexes * houses  #### Mapping * House ID - Equal To - house.houseCode
     * @summary Houses
     * @param chamberId Filter by house or committee uri. Example  /ie/oireachtas/house/dail/32
     * @param chamber Filter by House name (dail or seanad). Using an empty string retrieves results for both Houses.
     * @param skip This is a base filter which is used on many APIs, allowing skipping of records by a specific integer.
     * @param limit This is a base filter which is used on many APIs, allowing the limiting of records to a specific integer.
     */
    houses(chamberId, chamber, skip, limit) {
        const localVarPath = this.basePath + '/houses';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (chamberId !== undefined) {
            queryParameters['chamber_id'] = chamberId;
        }
        if (chamber !== undefined) {
            queryParameters['chamber'] = chamber;
        }
        if (skip !== undefined) {
            queryParameters['skip'] = skip;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.HousesApi = HousesApi;
var LegislationApiApiKeys;
(function (LegislationApiApiKeys) {
})(LegislationApiApiKeys = exports.LegislationApiApiKeys || (exports.LegislationApiApiKeys = {}));
class LegislationApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[LegislationApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns list of bills filtered by the base and additional parameters. The list supports paging. #### Indexes * billsbook_meta  #### Mapping * Start Date - Greater Than or Equal To - bill.mostRecentStage.event.dates.date * End Date - Less Than or Equal To - bill.mostRecentStage.event.dates.date * Skip - Equal To - this will ignore the first x number of records set in the parameter * Limit - Equal To - this will only return a specific amount of records * Status - Equal To - bill.status * Source - Equal To - bill.source *
     * @summary Legislation API
     * @param billStatus An array which is used to filter legislation by status detailed in default settings below.  Separated by comma.
     * @param billSource An array used to filter legislation by origin source.
     * @param dateStart This is a base filter which is used on many APIs, allowing filtering by Start Date related to the Section.
     * @param dateEnd This is a base filter which is used on many APIs, allowing filtering by End Date related to the Section.
     * @param skip This is a base filter which is used on many APIs, allowing skipping of records by a specific integer.
     * @param limit This is a base filter which is used on many APIs, allowing the limiting of records to a specific integer.
     * @param memberId Filter by Member uri.
     * @param billId Filter results by Bill URI Example   /ie/oireachtas/bill/2016/2
     * @param billNo Filter Bill by number.
     * @param billYear Filter Bill by year.
     * @param chamberId Filter by house or committee uri. Example  /ie/oireachtas/house/dail/32
     * @param actYear Filter Bill by Act year.
     * @param actNo Filter Bill by Act number.
     * @param lang language of document to extract. Defaults to English (en)
     */
    legislation(billStatus, billSource, dateStart, dateEnd, skip, limit, memberId, billId, billNo, billYear, chamberId, actYear, actNo, lang) {
        const localVarPath = this.basePath + '/legislation';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (billStatus !== undefined) {
            queryParameters['bill_status'] = billStatus;
        }
        if (billSource !== undefined) {
            queryParameters['bill_source'] = billSource;
        }
        if (dateStart !== undefined) {
            queryParameters['date_start'] = dateStart;
        }
        if (dateEnd !== undefined) {
            queryParameters['date_end'] = dateEnd;
        }
        if (skip !== undefined) {
            queryParameters['skip'] = skip;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (memberId !== undefined) {
            queryParameters['member_id'] = memberId;
        }
        if (billId !== undefined) {
            queryParameters['bill_id'] = billId;
        }
        if (billNo !== undefined) {
            queryParameters['bill_no'] = billNo;
        }
        if (billYear !== undefined) {
            queryParameters['bill_year'] = billYear;
        }
        if (chamberId !== undefined) {
            queryParameters['chamber_id'] = chamberId;
        }
        if (actYear !== undefined) {
            queryParameters['act_year'] = actYear;
        }
        if (actNo !== undefined) {
            queryParameters['act_no'] = actNo;
        }
        if (lang !== undefined) {
            queryParameters['lang'] = lang;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.LegislationApi = LegislationApi;
var PartiesApiApiKeys;
(function (PartiesApiApiKeys) {
})(PartiesApiApiKeys = exports.PartiesApiApiKeys || (exports.PartiesApiApiKeys = {}));
class PartiesApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[PartiesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns list of parties filtered by the base and additional parameters. The list supports paging. #### Mapping * Skip - Equal To - this will ignore the first x number of records set in the parameter * Limit - Equal To - this will only return a specific amount of records * House/Chamber - house.house.uri
     * @summary Parties List
     * @param chamberId Filter by house or committee uri. Example  /ie/oireachtas/house/dail/32
     * @param chamber Filter by House name (dail or seanad). Using an empty string retrieves results for both Houses.
     * @param houseNo filter by house number
     * @param skip This is a base filter which is used on many APIs, allowing skipping of records by a specific integer.
     * @param limit This is a base filter which is used on many APIs, allowing the limiting of records to a specific integer.
     */
    parties(chamberId, chamber, houseNo, skip, limit) {
        const localVarPath = this.basePath + '/parties';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (chamberId !== undefined) {
            queryParameters['chamber_id'] = chamberId;
        }
        if (chamber !== undefined) {
            queryParameters['chamber'] = chamber;
        }
        if (houseNo !== undefined) {
            queryParameters['house_no'] = houseNo;
        }
        if (skip !== undefined) {
            queryParameters['skip'] = skip;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.PartiesApi = PartiesApi;
var QuestionsApiApiKeys;
(function (QuestionsApiApiKeys) {
})(QuestionsApiApiKeys = exports.QuestionsApiApiKeys || (exports.QuestionsApiApiKeys = {}));
class QuestionsApi {
    constructor(basePathOrUsername, password, basePath) {
        this._basePath = defaultBasePath;
        this.defaultHeaders = {};
        this._useQuerystring = false;
        this.authentications = {
            'default': new VoidAuth(),
        };
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        }
        else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }
    set useQuerystring(value) {
        this._useQuerystring = value;
    }
    set basePath(basePath) {
        this._basePath = basePath;
    }
    get basePath() {
        return this._basePath;
    }
    setDefaultAuthentication(auth) {
        this.authentications.default = auth;
    }
    setApiKey(key, value) {
        this.authentications[QuestionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns list of questions filtered by the base and additional parameters. The list supports paging. #### Mapping * Start Date - Greater Than or Equal To - question.date * End Date - Less Than or Equal To - question.date * Skip - Equal To - this will ignore the first x number of records set in the parameter * Limit - Equal To - this will only return a specific amount of records * Question Type - question.questionType
     * @summary Questions Filtered by Type Only
     * @param dateStart This is a base filter which is used on many APIs, allowing filtering by Start Date related to the Section.
     * @param dateEnd This is a base filter which is used on many APIs, allowing filtering by End Date related to the Section.
     * @param skip This is a base filter which is used on many APIs, allowing skipping of records by a specific integer.
     * @param limit This is a base filter which is used on many APIs, allowing the limiting of records to a specific integer.
     * @param qtype Filter questions by oral or writtens.
     * @param memberId Filter by Member uri.
     * @param questionId Identifier for a Single Question
     * @param questionNo Filter by question No.
     */
    questions(dateStart, dateEnd, skip, limit, qtype, memberId, questionId, questionNo) {
        const localVarPath = this.basePath + '/questions';
        let queryParameters = {};
        let headerParams = Object.assign({}, this.defaultHeaders);
        let formParams = {};
        if (dateStart !== undefined) {
            queryParameters['date_start'] = dateStart;
        }
        if (dateEnd !== undefined) {
            queryParameters['date_end'] = dateEnd;
        }
        if (skip !== undefined) {
            queryParameters['skip'] = skip;
        }
        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }
        if (qtype !== undefined) {
            queryParameters['qtype'] = qtype;
        }
        if (memberId !== undefined) {
            queryParameters['member_id'] = memberId;
        }
        if (questionId !== undefined) {
            queryParameters['question_id'] = questionId;
        }
        if (questionNo !== undefined) {
            queryParameters['question_no'] = questionNo;
        }
        let useFormData = false;
        let requestOptions = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };
        this.authentications.default.applyToRequest(requestOptions);
        if (Object.keys(formParams).length) {
            if (useFormData) {
                requestOptions.formData = formParams;
            }
            else {
                requestOptions.form = formParams;
            }
        }
        return new Promise((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                }
                else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    }
                    else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
exports.QuestionsApi = QuestionsApi;
//# sourceMappingURL=api.js.map