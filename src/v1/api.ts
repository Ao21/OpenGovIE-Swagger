/**
 * Houses of the Oireachtas Open Data APIs
 * The Houses of the Oireachtas is providing these APIs to allow our datasets to be retrieved and reused as widely as possible. They are intended to be used in conjunction with https://data.oireachtas.ie, from where our datasets can be accessed directly. By using the APIs, users can make metadata queries to identify the specific data they require. New data are available through the API as soon as they are published.  Currently, https://data.oireachtas.ie contains data in XML format from the Official Report of the Houses of the Oireachtas (the \"debates\") and replies to Parliamentary Questions in XML files complying with the [Akoma Ntoso](http://akomantoso.org) schema, as well data in PDF format for Bills, Acts and other documents published by the Houses of the Oireachtas.  Files can be retrieved from https://data.oireachtas.ie by adding the URI fragment contained in the \"formats\" fields of the JSON documents returned by these APIs. At the moment only PDF and XML files are available directly from https://data.oireachtas.ie, but this will become the endpoint for direct access of all \"uri\" fields in the data queried through https://api.oireachtas.ie. We will also be making bulk downloads available through https://data.oireachtas.ie.  Please note the APIs are a work in progress. We are working on expanding the range of datasets we publish, and we are interested in hearing about how to make these APIs more useful and wide ranging. For these reasons, we welcome any feedback, suggestions and user stories to open.data@oireachtas.ie  Data published through these APIs are made available under the [Oireachtas (Open Data) PSI Licence](https://beta.oireachtas.ie/en/open-data/license/)
 *
 * OpenAPI spec version: 1.0
 * Contact: open.data@oireachtas.ie
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import request = require('request');
import http = require('http');
import Promise = require('bluebird');

let defaultBasePath = 'https://api.oireachtas.ie/v1';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

/* tslint:disable:no-unused-variable */

export class Act {
    'uri': string;
    'actYear': string;
    'actNo': string;
    'longTitleEn': string;
    'shortTitleEn': string;
    'dateSigned': string;
    'statutebookURI': string;
    'shortTitleGa': string;
    'longTitleGa': string;
}

export class AmendmentList {
    'stage': InlineResponse200BillOriginHouse;
    'date': string;
    'showAs': string;
    'stageNo': string;
    'formats': AmendmentlistFormats;
    'chamber': InlineResponse200BillOriginHouse;
}

export class AmendmentlistFormats {
    'pdf': InlineResponse2002DebateRecordDebateSectionFormatsPdf;
    'xml': InlineResponse2002DebateRecordDebateSectionFormatsPdf;
}

export class Debate {
    'debateSectionId': string;
    'date': string;
    'showAs': string;
    'uri': string;
    'chamber': InlineResponse200BillOriginHouse;
}

export class DebateFormats {
    'pdf': InlineResponse2002DebateRecordDebateSectionFormatsPdf;
    'xml': InlineResponse2002DebateRecordDebateSectionFormatsPdf;
}

export class DebateSpeaker {
    'memberCode': string;
    'showAs': string;
    'uri': string;
    'role': DebateSpeakerRole;
}

export class DebateSpeakerRole {
    'showAs': string;
    'uri': string;
    'roleCode': string;
    'roleType': DebateSpeakerRole.RoleTypeEnum;
}

export namespace DebateSpeakerRole {
    export enum RoleTypeEnum {
        Office = <any> 'office',
        Position = <any> 'position',
        Minister = <any> 'minister',
        MinisterState = <any> 'minister_state'
    }
}
export class DebateText {
    'speaker': DebateSpeaker;
    'textType': DebateText.TextTypeEnum;
    'text': string;
}

export namespace DebateText {
    export enum TextTypeEnum {
        Heading = <any> 'heading',
        Speech = <any> 'speech',
        Question = <any> 'question',
        Table = <any> 'table',
        Summary = <any> 'summary'
    }
}
export class ErrorResponse {
    'message': string;
}

export class Event {
    'showAs': string;
    'progressStage': number;
    'house': EventHouse;
    'dates': Array<EventDates>;
    'uri': string;
    'chamber': EventChamber;
}

export class EventChamber {
    'uri': string;
    'showAs': string;
}

export class EventDates {
    'date': string;
}

export class EventHouse {
    'showAs': string;
    'houseNo': string;
    'houseCode': EventHouse.HouseCodeEnum;
    'chamberCode': EventHouse.ChamberCodeEnum;
    'chamberType': EventHouse.ChamberTypeEnum;
    'uri': string;
}

export namespace EventHouse {
    export enum HouseCodeEnum {
        Dail = <any> 'dail',
        Seanad = <any> 'seanad'
    }
    export enum ChamberCodeEnum {
        Dail = <any> 'dail',
        Seanad = <any> 'seanad'
    }
    export enum ChamberTypeEnum {
        House = <any> 'house',
        Committee = <any> 'committee'
    }
}
export class Formats {
    'pdf': InlineResponse2002DebateRecordDebateSectionFormatsPdf;
    'xml': InlineResponse2002DebateRecordDebateSectionFormatsPdf;
}

export class Head {
    'counts': any;
    'dateRange': HeadDateRange;
    'lang': Head.LangEnum;
}

export namespace Head {
    export enum LangEnum {
        En = <any> 'en',
        Ga = <any> 'ga',
        Mul = <any> 'mul'
    }
}
export class HeadDateRange {
    'start': Date;
    'end': Date;
}

export class InlineResponse200 {
    'head': Head;
    'results': Array<InlineResponse200Results>;
}

export class InlineResponse2001 {
    'head': Head;
    'results': Array<InlineResponse2001Results>;
}

export class InlineResponse2001Question {
    'questionNumber': number;
    'uri': string;
    'questionType': InlineResponse2001Question.QuestionTypeEnum;
    'by': InlineResponse2001QuestionBy;
    'date': string;
    'debateSection': InlineResponse2001QuestionDebateSection;
    'showAs': string;
    'answerText': string;
    'to': InlineResponse2001QuestionTo;
}

export namespace InlineResponse2001Question {
    export enum QuestionTypeEnum {
        Oral = <any> 'oral',
        Written = <any> 'written'
    }
}
export class InlineResponse2001QuestionBy {
    'showAs': string;
    'uri': string;
    'memberCode': string;
}

export class InlineResponse2001QuestionDebateSection {
    'debateSectionId': string;
    'showAs': string;
    'uri': string;
    'formats': InlineResponse2001QuestionDebateSectionFormats;
}

export class InlineResponse2001QuestionDebateSectionFormats {
    'pdf': InlineResponse2001QuestionDebateSectionFormatsPdf;
    'xml': InlineResponse2001QuestionDebateSectionFormatsXml;
}

export class InlineResponse2001QuestionDebateSectionFormatsPdf {
    'uri': string;
}

export class InlineResponse2001QuestionDebateSectionFormatsXml {
    'uri': string;
}

export class InlineResponse2001QuestionTo {
    'showAs': string;
    'uri': string;
    'roleType': InlineResponse2001QuestionTo.RoleTypeEnum;
    'roleCode': string;
}

export namespace InlineResponse2001QuestionTo {
    export enum RoleTypeEnum {
        Office = <any> 'office',
        Minister = <any> 'minister'
    }
}
export class InlineResponse2001Results {
    'question': InlineResponse2001Question;
}

export class InlineResponse2002 {
    'head': Head;
    'results': Array<InlineResponse2002Results>;
}

export class InlineResponse2002DebateRecord {
    'lastUpdated': Date;
    'chamber': InlineResponse2002DebateRecordChamber;
    'house': InlineResponse2002DebateRecordHouse;
    'counts': InlineResponse2002DebateRecordCounts;
    'uri': string;
    'formats': DebateFormats;
    'debateSections': Array<InlineResponse2002DebateRecordDebateSections>;
    'date': string;
}

export class InlineResponse2002DebateRecordChamber {
    'showAs': string;
    'uri': InlineResponse2002DebateRecordChamber.UriEnum;
}

export namespace InlineResponse2002DebateRecordChamber {
    export enum UriEnum {
        Housedail = <any> '/ie/oireachtas/house/dail',
        Houseseanad = <any> '/ie/oireachtas/house/seanad',
        Committee = <any> '/ie/oireachtas/committee'
    }
}
export class InlineResponse2002DebateRecordCounts {
    'debateSectionCount': number;
    'contributorCount': number;
    'divisionCount': number;
    'questionCount': number;
    'billCount': number;
}

export class InlineResponse2002DebateRecordDebateSection {
    'text': Array<DebateText>;
    'showAs': string;
    'debateType': string;
    'counts': InlineResponse2002DebateRecordDebateSectionCounts;
    'speakers': Array<InlineResponse2002DebateRecordDebateSectionSpeakers>;
    'bill': InlineResponse2002DebateRecordDebateSectionBill;
    'containsDebate': boolean;
    'uri': string;
    'debateSectionId': string;
    'formats': InlineResponse2002DebateRecordDebateSectionFormats;
    'parentDebateSection': InlineResponse2002DebateRecordDebateSectionParentDebateSection;
}

export class InlineResponse2002DebateRecordDebateSectionBill {
    'uri': string;
    'event': InlineResponse2002DebateRecordDebateSectionBillEvent;
}

export class InlineResponse2002DebateRecordDebateSectionBillEvent {
    'showAs': string;
    'uri': string;
    'stage': string;
    'motionType': string;
    'houseCode': string;
    'isBillStage': boolean;
}

export class InlineResponse2002DebateRecordDebateSectionCounts {
    'speechCount': number;
    'speakerCount': number;
}

export class InlineResponse2002DebateRecordDebateSectionFormats {
    'pdf': InlineResponse2002DebateRecordDebateSectionFormatsPdf;
    'xml': InlineResponse2002DebateRecordDebateSectionFormatsPdf;
}

export class InlineResponse2002DebateRecordDebateSectionFormatsPdf {
    'uri': string;
}

export class InlineResponse2002DebateRecordDebateSectionParentDebateSection {
    'showAs': string;
    'uri': string;
    'formats': InlineResponse2002DebateRecordDebateSectionFormats;
    'debateSectionId': string;
}

export class InlineResponse2002DebateRecordDebateSectionSpeakers {
    'speaker': DebateSpeaker;
}

export class InlineResponse2002DebateRecordDebateSections {
    'debateSection': InlineResponse2002DebateRecordDebateSection;
}

export class InlineResponse2002DebateRecordHouse {
    'uri': string;
    'houseNo': string;
    'showAs': string;
    'houseCode': InlineResponse2002DebateRecordHouse.HouseCodeEnum;
    'committeeCode': string;
    'chamberType': InlineResponse2002DebateRecordHouse.ChamberTypeEnum;
}

export namespace InlineResponse2002DebateRecordHouse {
    export enum HouseCodeEnum {
        Dail = <any> 'dail',
        Seanad = <any> 'seanad'
    }
    export enum ChamberTypeEnum {
        House = <any> 'house',
        Committee = <any> 'committee'
    }
}
export class InlineResponse2002Results {
    'debateRecord': InlineResponse2002DebateRecord;
}

export class InlineResponse2003 {
    'head': Head;
    'results': Array<InlineResponse2003Results>;
}

export class InlineResponse2003Division {
    'isBill': boolean;
    'debate': InlineResponse2003DivisionDebate;
    'voteId': string;
    'datetime': Date;
    'tallies': InlineResponse2003DivisionTallies;
    'chamber': InlineResponse200BillOriginHouse;
    'category': string;
    'subject': InlineResponse200BillOriginHouse;
    'uri': string;
    'outcome': string;
    'tellers': string;
    'house': InlineResponse2003DivisionHouse;
    'date': string;
}

export class InlineResponse2003DivisionDebate {
    'showAs': string;
    'uri': string;
    'formats': InlineResponse2003DivisionDebateFormats;
    'debateSection': string;
}

export class InlineResponse2003DivisionDebateFormats {
    'pdf': InlineResponse2003DivisionDebateFormatsPdf;
    'xml': InlineResponse2003DivisionDebateFormatsXml;
}

export class InlineResponse2003DivisionDebateFormatsPdf {
    'uri': string;
}

export class InlineResponse2003DivisionDebateFormatsXml {
    'uri': string;
}

export class InlineResponse2003DivisionHouse {
    'uri': string;
    'houseNo': string;
    'houseCode': string;
    'chamberType': string;
    'showAs': string;
    'committeeCode': string;
}

export class InlineResponse2003DivisionTallies {
    'nilVotes': MemberTally;
    'taVotes': MemberTally;
    'staonVotes': MemberTally;
}

export class InlineResponse2003Results {
    'division': InlineResponse2003Division;
}

export class InlineResponse200Bill {
    'debates': Array<Debate>;
    'sponsors': Array<Sponsor>;
    'lastUpdated': Date;
    'longTitleEn': string;
    'longTitleGa': string;
    'originHouse': InlineResponse200BillOriginHouse;
    'shortTitleEn': string;
    'shortTitleGa': string;
    'status': InlineResponse200Bill.StatusEnum;
    'billType': InlineResponse200Bill.BillTypeEnum;
    'events': Array<Event>;
    'mostRecentStage': InlineResponse200BillMostRecentStage;
    'uri': string;
    'act': Act;
    'amendmentLists': Array<InlineResponse200BillAmendmentLists>;
    'billYear': string;
    'relatedDocs': Array<RelatedDoc>;
    'billNo': string;
    'stages': Array<InlineResponse200BillMostRecentStage>;
    'method': string;
    'source': string;
    'versions': Array<InlineResponse200BillVersions>;
}

export namespace InlineResponse200Bill {
    export enum StatusEnum {
        Defeated = <any> 'Defeated',
        Enacted = <any> 'Enacted',
        Lapsed = <any> 'Lapsed',
        Current = <any> 'Current',
        Withdrawn = <any> 'Withdrawn',
        Rejected = <any> 'Rejected'
    }
    export enum BillTypeEnum {
        Public = <any> 'Public',
        Private = <any> 'Private',
        Hybrid = <any> 'Hybrid'
    }
}
export class InlineResponse200BillAmendmentLists {
    'amendmentList': AmendmentList;
}

export class InlineResponse200BillMostRecentStage {
    'event': Event;
}

export class InlineResponse200BillOriginHouse {
    'showAs': string;
    'uri': string;
}

export class InlineResponse200BillVersion {
    'date': string;
    'formats': VersionFormats;
    'text': string;
    'lang': InlineResponse200BillVersion.LangEnum;
    'showAs': string;
    'uri': string;
}

export namespace InlineResponse200BillVersion {
    export enum LangEnum {
        Eng = <any> 'eng',
        Gle = <any> 'gle'
    }
}
export class InlineResponse200BillVersions {
    'version': InlineResponse200BillVersion;
}

export class InlineResponse200Results {
    'bill': InlineResponse200Bill;
}

export class MemberTally {
    'tally': number;
    'showAs': string;
    'members': Array<MemberTallyMembers>;
}

export class MemberTallyMember {
    'showAs': string;
    'memberCode': string;
    'uri': string;
}

export class MemberTallyMembers {
    'member': MemberTallyMember;
}

export class RelatedDoc {
    'date': string;
    'formats': Formats;
    'showAs': string;
    'uri': string;
    'docType': string;
}

export class Sponsor {
    'sponsor': SponsorSponsor;
}

export class SponsorSponsor {
    'by': InlineResponse200BillOriginHouse;
    'as': InlineResponse200BillOriginHouse;
}

export class VersionFormats {
    'pdf': InlineResponse2002DebateRecordDebateSectionFormatsPdf;
    'xml': InlineResponse2002DebateRecordDebateSectionFormatsPdf;
}


export interface Authentication {
    /**
    * Apply authentication settings to header and query params.
    */
    applyToRequest(requestOptions: request.Options): void;
}

export class HttpBasicAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(requestOptions: request.Options): void {
        requestOptions.auth = {
            username: this.username, password: this.password
        }
    }
}

export class ApiKeyAuth implements Authentication {
    public apiKey: string;

    constructor(private location: string, private paramName: string) {
    }

    applyToRequest(requestOptions: request.Options): void {
        if (this.location == "query") {
            (<any>requestOptions.qs)[this.paramName] = this.apiKey;
        } else if (this.location == "header" && requestOptions && requestOptions.headers) {
            requestOptions.headers[this.paramName] = this.apiKey;
        }
    }
}

export class OAuth implements Authentication {
    public accessToken: string;

    applyToRequest(requestOptions: request.Options): void {
        if (requestOptions && requestOptions.headers) {
            requestOptions.headers["Authorization"] = "Bearer " + this.accessToken;
        }
    }
}

export class VoidAuth implements Authentication {
    public username: string;
    public password: string;
    applyToRequest(_: request.Options): void {
        // Do nothing
    }
}

export enum ConstituenciesApiApiKeys {
}

export class ConstituenciesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: ConstituenciesApiApiKeys, value: string) {
        this.authentications[ConstituenciesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns list of constituencies filtered by the base and additional parameters. The list supports paging.  #### Mapping * Start Date - Greater Than or Equal To - question.date * End Date - Less Than or Equal To - question.date * Skip - Equal To - this will ignore the first x number of records set in the parameter * Limit - Equal To - this will only return a specific amount of records * House/Chamber - house.house.uri 
     * @summary Constituencies List
     * @param chamberId Filter by house or committee uri. Example  /ie/oireachtas/house/dail/32 
     * @param chamber Filter by House name (dail or seanad). Using an empty string retrieves results for both Houses. 
     * @param houseNo filter by house number
     * @param skip This is a base filter which is used on many APIs, allowing skipping of records by a specific integer.
     * @param limit This is a base filter which is used on many APIs, allowing the limiting of records to a specific integer.
     */
    public constituencies (chamberId?: Array<string>, chamber?: string, houseNo?: number, skip?: number, limit?: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/constituencies';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (chamberId !== undefined) {
            queryParameters['chamber_id'] = chamberId;
        }

        if (chamber !== undefined) {
            queryParameters['chamber'] = chamber;
        }

        if (houseNo !== undefined) {
            queryParameters['house_no'] = houseNo;
        }

        if (skip !== undefined) {
            queryParameters['skip'] = skip;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DebatesApiApiKeys {
}

export class DebatesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DebatesApiApiKeys, value: string) {
        this.authentications[DebatesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns list of debates filtered by the base and additional parameters. The list supports paging. #### Mapping * Start Date - Greater Than or Equal To - debateRecord.date * End Date - Less Than or Equal To - debateRecord.date * Skip - Equal To - this will ignore the first x number of records set in the parameter * Limit - Equal To - this will only return a specific amount of records 
     * @summary Debates List
     * @param chamberType Filter results by House, ie, Dáil or Seanad or committees. 
     * @param chamberId Filter by house or committee uri. Example  /ie/oireachtas/house/dail/32 
     * @param chamber Filter by House name (dail or seanad). Using an empty string retrieves results for both Houses. 
     * @param dateStart This is a base filter which is used on many APIs, allowing filtering by Start Date related to the Section.
     * @param dateEnd This is a base filter which is used on many APIs, allowing filtering by End Date related to the Section.
     * @param skip This is a base filter which is used on many APIs, allowing skipping of records by a specific integer.
     * @param limit This is a base filter which is used on many APIs, allowing the limiting of records to a specific integer.
     * @param memberId Filter by Member uri.
     * @param debateId Filter by debate uri
     */
    public debates (chamberType?: string, chamberId?: Array<string>, chamber?: string, dateStart?: Date, dateEnd?: Date, skip?: number, limit?: number, memberId?: string, debateId?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse2002;  }> {
        const localVarPath = this.basePath + '/debates';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (chamberType !== undefined) {
            queryParameters['chamber_type'] = chamberType;
        }

        if (chamberId !== undefined) {
            queryParameters['chamber_id'] = chamberId;
        }

        if (chamber !== undefined) {
            queryParameters['chamber'] = chamber;
        }

        if (dateStart !== undefined) {
            queryParameters['date_start'] = dateStart;
        }

        if (dateEnd !== undefined) {
            queryParameters['date_end'] = dateEnd;
        }

        if (skip !== undefined) {
            queryParameters['skip'] = skip;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (memberId !== undefined) {
            queryParameters['member_id'] = memberId;
        }

        if (debateId !== undefined) {
            queryParameters['debate_id'] = debateId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2002;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum DivisionsApiApiKeys {
}

export class DivisionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: DivisionsApiApiKeys, value: string) {
        this.authentications[DivisionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * This will return a list of divisions which meet certain criteria #### Indexes * division_meta  #### Mapping * Division outcome - Equal To - division.outcome * Start Date - Greater than or Equal To - division.date * End Date - Greater than or Equal To - division.date 
     * @summary Divisions
     * @param chamberType Filter results by House, ie, Dáil or Seanad or committees. 
     * @param chamberId Filter by house or committee uri. Example  /ie/oireachtas/house/dail/32 
     * @param chamber Filter by House name (dail or seanad). Using an empty string retrieves results for both Houses. 
     * @param dateStart This is a base filter which is used on many APIs, allowing filtering by Start Date related to the Section.
     * @param dateEnd This is a base filter which is used on many APIs, allowing filtering by End Date related to the Section.
     * @param skip This is a base filter which is used on many APIs, allowing skipping of records by a specific integer.
     * @param limit This is a base filter which is used on many APIs, allowing the limiting of records to a specific integer.
     * @param outcome Filter divisions by outcome
     * @param memberId Filter by Member uri.
     * @param debateId Filter by debate uri
     * @param voteId Division Identifier for a Single Division
     */
    public divisions (chamberType?: string, chamberId?: Array<string>, chamber?: string, dateStart?: Date, dateEnd?: Date, skip?: number, limit?: number, outcome?: Array<string>, memberId?: string, debateId?: string, voteId?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse2003;  }> {
        const localVarPath = this.basePath + '/divisions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (chamberType !== undefined) {
            queryParameters['chamber_type'] = chamberType;
        }

        if (chamberId !== undefined) {
            queryParameters['chamber_id'] = chamberId;
        }

        if (chamber !== undefined) {
            queryParameters['chamber'] = chamber;
        }

        if (dateStart !== undefined) {
            queryParameters['date_start'] = dateStart;
        }

        if (dateEnd !== undefined) {
            queryParameters['date_end'] = dateEnd;
        }

        if (skip !== undefined) {
            queryParameters['skip'] = skip;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (outcome !== undefined) {
            queryParameters['outcome'] = outcome;
        }

        if (memberId !== undefined) {
            queryParameters['member_id'] = memberId;
        }

        if (debateId !== undefined) {
            queryParameters['debate_id'] = debateId;
        }

        if (voteId !== undefined) {
            queryParameters['vote_id'] = voteId;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2003;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum HousesApiApiKeys {
}

export class HousesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: HousesApiApiKeys, value: string) {
        this.authentications[HousesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns a house. #### Indexes * houses  #### Mapping * House ID - Equal To - house.houseCode 
     * @summary Houses
     * @param chamberId Filter by house or committee uri. Example  /ie/oireachtas/house/dail/32 
     * @param chamber Filter by House name (dail or seanad). Using an empty string retrieves results for both Houses. 
     * @param skip This is a base filter which is used on many APIs, allowing skipping of records by a specific integer.
     * @param limit This is a base filter which is used on many APIs, allowing the limiting of records to a specific integer.
     */
    public houses (chamberId?: Array<string>, chamber?: string, skip?: number, limit?: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/houses';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (chamberId !== undefined) {
            queryParameters['chamber_id'] = chamberId;
        }

        if (chamber !== undefined) {
            queryParameters['chamber'] = chamber;
        }

        if (skip !== undefined) {
            queryParameters['skip'] = skip;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum LegislationApiApiKeys {
}

export class LegislationApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: LegislationApiApiKeys, value: string) {
        this.authentications[LegislationApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns list of bills filtered by the base and additional parameters. The list supports paging. #### Indexes * billsbook_meta  #### Mapping * Start Date - Greater Than or Equal To - bill.mostRecentStage.event.dates.date * End Date - Less Than or Equal To - bill.mostRecentStage.event.dates.date * Skip - Equal To - this will ignore the first x number of records set in the parameter * Limit - Equal To - this will only return a specific amount of records * Status - Equal To - bill.status * Source - Equal To - bill.source * 
     * @summary Legislation API
     * @param billStatus An array which is used to filter legislation by status detailed in default settings below.  Separated by comma.
     * @param billSource An array used to filter legislation by origin source.
     * @param dateStart This is a base filter which is used on many APIs, allowing filtering by Start Date related to the Section.
     * @param dateEnd This is a base filter which is used on many APIs, allowing filtering by End Date related to the Section.
     * @param skip This is a base filter which is used on many APIs, allowing skipping of records by a specific integer.
     * @param limit This is a base filter which is used on many APIs, allowing the limiting of records to a specific integer.
     * @param memberId Filter by Member uri.
     * @param billId Filter results by Bill URI Example   /ie/oireachtas/bill/2016/2 
     * @param billNo Filter Bill by number.
     * @param billYear Filter Bill by year.
     * @param chamberId Filter by house or committee uri. Example  /ie/oireachtas/house/dail/32 
     * @param actYear Filter Bill by Act year.
     * @param actNo Filter Bill by Act number.
     * @param lang language of document to extract. Defaults to English (en)
     */
    public legislation (billStatus?: Array<string>, billSource?: Array<string>, dateStart?: Date, dateEnd?: Date, skip?: number, limit?: number, memberId?: string, billId?: string, billNo?: string, billYear?: string, chamberId?: Array<string>, actYear?: string, actNo?: string, lang?: string) : Promise<{ response: http.ClientResponse; body: InlineResponse200;  }> {
        const localVarPath = this.basePath + '/legislation';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (billStatus !== undefined) {
            queryParameters['bill_status'] = billStatus;
        }

        if (billSource !== undefined) {
            queryParameters['bill_source'] = billSource;
        }

        if (dateStart !== undefined) {
            queryParameters['date_start'] = dateStart;
        }

        if (dateEnd !== undefined) {
            queryParameters['date_end'] = dateEnd;
        }

        if (skip !== undefined) {
            queryParameters['skip'] = skip;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (memberId !== undefined) {
            queryParameters['member_id'] = memberId;
        }

        if (billId !== undefined) {
            queryParameters['bill_id'] = billId;
        }

        if (billNo !== undefined) {
            queryParameters['bill_no'] = billNo;
        }

        if (billYear !== undefined) {
            queryParameters['bill_year'] = billYear;
        }

        if (chamberId !== undefined) {
            queryParameters['chamber_id'] = chamberId;
        }

        if (actYear !== undefined) {
            queryParameters['act_year'] = actYear;
        }

        if (actNo !== undefined) {
            queryParameters['act_no'] = actNo;
        }

        if (lang !== undefined) {
            queryParameters['lang'] = lang;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse200;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum PartiesApiApiKeys {
}

export class PartiesApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: PartiesApiApiKeys, value: string) {
        this.authentications[PartiesApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns list of parties filtered by the base and additional parameters. The list supports paging. #### Mapping * Skip - Equal To - this will ignore the first x number of records set in the parameter * Limit - Equal To - this will only return a specific amount of records * House/Chamber - house.house.uri 
     * @summary Parties List
     * @param chamberId Filter by house or committee uri. Example  /ie/oireachtas/house/dail/32 
     * @param chamber Filter by House name (dail or seanad). Using an empty string retrieves results for both Houses. 
     * @param houseNo filter by house number
     * @param skip This is a base filter which is used on many APIs, allowing skipping of records by a specific integer.
     * @param limit This is a base filter which is used on many APIs, allowing the limiting of records to a specific integer.
     */
    public parties (chamberId?: Array<string>, chamber?: string, houseNo?: number, skip?: number, limit?: number) : Promise<{ response: http.ClientResponse; body?: any;  }> {
        const localVarPath = this.basePath + '/parties';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (chamberId !== undefined) {
            queryParameters['chamber_id'] = chamberId;
        }

        if (chamber !== undefined) {
            queryParameters['chamber'] = chamber;
        }

        if (houseNo !== undefined) {
            queryParameters['house_no'] = houseNo;
        }

        if (skip !== undefined) {
            queryParameters['skip'] = skip;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body?: any;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
export enum QuestionsApiApiKeys {
}

export class QuestionsApi {
    protected _basePath = defaultBasePath;
    protected defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
	this.authentications.default = auth;
    }

    public setApiKey(key: QuestionsApiApiKeys, value: string) {
        this.authentications[QuestionsApiApiKeys[key]].apiKey = value;
    }
    /**
     * Returns list of questions filtered by the base and additional parameters. The list supports paging. #### Mapping * Start Date - Greater Than or Equal To - question.date * End Date - Less Than or Equal To - question.date * Skip - Equal To - this will ignore the first x number of records set in the parameter * Limit - Equal To - this will only return a specific amount of records * Question Type - question.questionType 
     * @summary Questions Filtered by Type Only
     * @param dateStart This is a base filter which is used on many APIs, allowing filtering by Start Date related to the Section.
     * @param dateEnd This is a base filter which is used on many APIs, allowing filtering by End Date related to the Section.
     * @param skip This is a base filter which is used on many APIs, allowing skipping of records by a specific integer.
     * @param limit This is a base filter which is used on many APIs, allowing the limiting of records to a specific integer.
     * @param qtype Filter questions by oral or writtens.
     * @param memberId Filter by Member uri.
     * @param questionId Identifier for a Single Question
     * @param questionNo Filter by question No.
     */
    public questions (dateStart?: Date, dateEnd?: Date, skip?: number, limit?: number, qtype?: Array<string>, memberId?: string, questionId?: string, questionNo?: number) : Promise<{ response: http.ClientResponse; body: InlineResponse2001;  }> {
        const localVarPath = this.basePath + '/questions';
        let queryParameters: any = {};
        let headerParams: any = (<any>Object).assign({}, this.defaultHeaders);
        let formParams: any = {};


        if (dateStart !== undefined) {
            queryParameters['date_start'] = dateStart;
        }

        if (dateEnd !== undefined) {
            queryParameters['date_end'] = dateEnd;
        }

        if (skip !== undefined) {
            queryParameters['skip'] = skip;
        }

        if (limit !== undefined) {
            queryParameters['limit'] = limit;
        }

        if (qtype !== undefined) {
            queryParameters['qtype'] = qtype;
        }

        if (memberId !== undefined) {
            queryParameters['member_id'] = memberId;
        }

        if (questionId !== undefined) {
            queryParameters['question_id'] = questionId;
        }

        if (questionNo !== undefined) {
            queryParameters['question_no'] = questionNo;
        }

        let useFormData = false;

        let requestOptions: request.Options = {
            method: 'GET',
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        this.authentications.default.applyToRequest(requestOptions);

        if (Object.keys(formParams).length) {
            if (useFormData) {
                (<any>requestOptions).formData = formParams;
            } else {
                requestOptions.form = formParams;
            }
        }
        return new Promise<{ response: http.ClientResponse; body: InlineResponse2001;  }>((resolve, reject) => {
            request(requestOptions, (error, response, body) => {
                if (error) {
                    reject(error);
                } else {
                    if (response.statusCode >= 200 && response.statusCode <= 299) {
                        resolve({ response: response, body: body });
                    } else {
                        reject({ response: response, body: body });
                    }
                }
            });
        });
    }
}
